# Panic 
In rust it simply means that we are going to get the error during the runtime.
# Overhead 
In computing, "overhead" refers to the additional resources, time, or processing required by a system or operation beyond what is strictly necessary to perform the desired task. Overhead can manifest in various forms, including:
# Unsafe 
"unsafe code" refers to code that is allowed to perform certain operations that are considered unsafe by the Rust language's safety guarantees. This includes:
# Small optimazations 
Means small/mionor  changes in the program made to code that result in the improvement of the performance .
# Push Insert 
The main difference between push and insert is that. Push put the elements at the end of the vector on the other side insert puts the element at the specified place by shifitng the element.

Dereferencing raw pointers.
Calling unsafe functions or methods.
Accessing or modifying mutable static variables.
Implementing unsafe traits.
Accessing or modifying mutable data without synchronization.
Invoking undefined behavior.

# TUPLE
A tuple is a collection of values of different types.
Tuple are stored in contagenious memory location.
Tuple are immutable by default.
Tuples are simple data structures, offering efficient memory usage for fixed-size collections of different types.
Their immutability ensures memory safety and simplifies reasoning about data access
```Rust 
fn main(){
    let i=('l','k','f',1,8.2);
    println!(" THE value at the index 5 is {}",i.4);
}
```  

# Control flow
It is the flow of program in which it check the condition and give the result on the basis of that .
In rust we can use ```if```it allow us to branch the code depending upon the condition .
```Rust
 fn main(){
    let x=4;
    ifx ==4{
        println!("The value is correct ");
    }
 }
```
We can use ```else``` with ```if ```
```Rust
fn main(){
    let x=48;
    if x<48{
        println!("x is less then 48");
}else {
    println!("The vslue is more then the require one");
}
}
```
# Loop
In Rust we use Loop keyword to repeat the itteration again and again 
We have to explictily stop the loop by using the  ```Ctrl+c```
```Rust
fn main(){
    loop{
        println!("The loop is looop")
    }
}
To stop this loop we use ctrl+c keyword
```


# RUST Ownership and Borrowing 
Ownership is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.
## Rules of ownership
 [1] There is only owner at a time 
 [2] Each value in rust has owner
 [3]  When the owner goes out of the scope, the value will be dropped.
 # Here is the simple demostrtion
 ```Rust
 fn main(){
 {let k: i32=5; //In this we have defined scope under {} and this is type of varible scope
 println!("s= {}",k);
 }
 println!("s= {}",k); //When we will call this it will give error in program As it is out of scope 
 
}

```
# Returning value from loops


Here is reason why string can be mutaed but string litrals can't.
As we know that string litral content is known at the compile time and its text is hardcoded directly into the final executable .
In case of string we need to allocate an amount of memory on the heap, unknown at the compile time .
# Memoery allocation in rust 
Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope.Then rust called ```drop``` it is function which is automactically called when there is closing curly brakets. 

# Variables and data Interacting 
# Move
Move it is concept in which rust validate the first varible instead of being called a shallow copy it is known as move.
```Rust 
fn main(){
let s1 =String::from("Kaushik rah ");
let s2=s1;
print!("This  is {}",s1);
}
//This code wont work as the value of s1 as been moved to s2 
fn main(){
let s1 =String::from("Kaushik raj ");
let s2=s1;

print!("This  is {}",s2);
}
//On the other this code will run as we call the varible s2 beacuse the ownership of s1 has been passed to s2.
```
# Clone 
 This is concept in rust where it clone the data of data of one variable to another .
 ```Rust
 fn main(){
    let c=String::from("Hey kaushik raj ");
    let d=c.clone();
    println!("This is the value of x = {},This is value of y={}"c ,d);
 }
 
 ```



 This line of code will give error as it we have complex data of string and we cant assign both of them.
 ```Rust
 fn main(){
let x=String::from ("HI");
let y=x;
print!("y is {}",x);
}
```
But on the other side this line of code wont give you error.
 ```RUST
 fn main(){
let x= "HI";
let y=x;
print!("y is {}",x);
}
 ```

 Ownership and Borrowing are why Rust is Rust .
 Owner ship simpliy means owning some amount if memory .
 Initially frustrates both the new and senior developers
 Memory Management 
 No garbage collection 
 Developer manages memoery in code 
 Stacks VS Heap
 Benefits 
 Runtime speed
 Parallel and Concurrent processing 
 Safety 
 In rust memory time is known at the compile time.
 In rust every piece of data in the memory has an memory and there can be only a single owner of memory at a time.
 String is just a collection of u8.
 # Stack
 It store the in the order it gets them and remove the values in the opposite order .It work in the concept of LIFO
 Stack in rust is having known,fixed size.
 Addig data is known is push.
 And removing of data is pop.
 # Heap
 It is less organized,In this when we some amount of data it request for the certain space in  memory .Memory allocator find the space and return a pointer which is adrres of the location.

# Slice 
It is similiar to array but its size is not known at the compile time .
Its two word objet, the first is known as pointer of the data ,the secod is known as the length ogf the slice .


 

 ```Rust
 #[allow(unused_variables)] //This is so i dont get warning throughout the coding .
 `#[allow(dead_code)]` //is an attribute that disables the `dead_code` lint.
 ```
# Reference and borrowing 
A reference is way to acces or refer to a value stored in memory.It is used to pass the data between program.
Dereference is used to access the value of that a reference point is .
```Rust
fn main(){
    let m =45;
    let d=&m;
    println!("{}",d);
    let d1=d;
     println!("{}",m);

}
```
A reference is like a pointer it that its address we can follow to acces the data stored at that address, and that data is owned by some other varible.It guranteed that it will point to that particular data. It should be under scope of the varible. The reference is most common pointer .
It boorow the value of which it has benn pointed .
```Rust
fn main(){
  { let s=5;
   println!("The vsl is ={}",s);};
   let j= &s;
   println!("The vsl is ={}",j);

    }
    //This will generate the error as it going varible is out of the scope 
    fn main(){
     let s=5;
   println!("The vsl is ={}",s);;
   let j= &s;
   println!("The vsl is ={}",j);

    }
    //This will not generate the error it  will properly work on the cocept of refence and borrowing 
``` 
In refernce it can just borrow the data .
# Dereference 
This is use to borrow the data from the pointer/ refernce which haas been borrowed from the original one.
```Rust 
fn main(){
    let c=45;
    let d=&c;
    let x=*d;
    println!("The value of x is {}",x);
}

```


# Pointer
In rust we have smart pointer which is like data structure and work similiarly like pointer .
There are many smart pointer in rust std lib and all work is to allow you to have multiple owners by keepinf the tracks of the number of owner and when no owner remain,cleaing up the data .
Apart from borrowing ,the rust smart pointer have capabilities to own the data .
Smart pointer are usually implemented with with the struct .
It usually do  implementation on the ```DREF ``` AND ```Drop```
# Using BOX
A ```BOX``` is a pointer type that uniquely owns a heap allocation of type T.
Box have unknown size .
```New``` is keyword that Allocates memory on the heap and then places x into it.
```Rust
fn main(){
    let x =Box::new (5);
    println!("The value of x is {}",x);
}
```
# Function
 It is declared using the fn keyword.
 Unlike other language,here function defination have no restriction on the function order.
 n Rust, ``` && ```is the logical ```AND operator```. It's used to combine two boolean expressions and returns true only if both expressions are true.
 ```RUST
 #[allow(unused_variables )]
#[allow(unused_allocation)]
#[allow(dead_code)]  //This is rust lnt 
fn  add (a:i32, b:i32){
    a+b;
    println!("the value of add is {}",a+b)

} fn main ()
{
    add(45, 25);
    add(4578,56423)
}
```
Here I  have explain few example for the the function.
```Rust
#[allow(dead_code)]
fn main(){
sun(456, 552);
square(5);
maxium(50, 5, 23)
}
fn sun(a:i128,b:i128){
   let c= a-b;
    println!("The value is {} ",c)

}
 fn square (x:i8){
    let p= x*x;
    println!("The square  of x is {} ",p)

 }
 
    fn maxium (h:i8,k:i8,p:i8){
     if h>p &&p>k{
      println!("h is greter ");
     } 
        
     }
    
 

    
```






















# Generic
 Generics refer to a feature that allows you to write code that can operate on different data types while maintaining type safety. Generics enable you to create reusable components (such as functions, structs, or enums) that can work with any data type.
There is no runtime cost in rust. Which means that we 
We can use as many as generic we want 
We just need to define it on Placeholder < Anything in case try upper case >.
In simple terms we can say that we are defing the multiple data types in one go from int to bool and so on.
In therory Generics are called ‘parametric polymorphism’ in type theory, which means that they are types or functions that have multiple forms (‘poly’ is multiple, ‘morph’ is form) over a given parameter (‘parametric’).
Note it is always advisble not to use more genric always.

```rust
struct Point<A,B>{
    x:A,
    y:B,
}

fn main() {
    let a=Point{x:78,y:85.47};
    let v=Point{x:-7,y:956};
     println!("x ={} y={}",a.x,a.y);
     println!("x ={} y={}",v.x,v.y);
     
    
}

```





# Traits
Definig shared behaviour(means method) using traits.
Traits allow us define set of method that are shared across different types 

This is for the concurency control.
The main building block for createing the concurent in rust is a "thread".
There are two main two types of thread in programing in thread .
First type is OS thread.It is offered by OS iteslef.
Second types is Green thread.Its an abstraction thats sit ontop of the operating system thread.
Rust uses the opeerating system thread directly and the reason why is for the the sake of hai=ving a lowet runtike by the lower runtime means the lower amount of code included in each binay after its compiled .
While creating a thread we need to bring the thread namespace first .
Rust doesen't make the gurantee  of the thread order .
# MOVE 
Move(KEYWORD) allow the clouser to move data from one thread to another THREAD and we take the ownership of the main thread.
Move key word force the clousre to refernce data by the value rather than by the reference 
# SECOND ABSTRACTION
Rust uses second abstraction which is called channels.
Channels are use to pass the messsage around and channel is made up of a transmitter which is TX ans a reciver which is RX .
Transmitter is the part that sits upstream where we actually push the message in and then the reciver is where msg come out.
We destruct the tuple that is returned by the channel method and the TX HAS SEND method that takes the value we want to send and return  a result and thats why we use unwrap .
 # ARRAY 
 In array we have some built in functionality with the rust 
 In rust array list is preety much vector.
 Its is knowns at the complie time and its slice is not  known at the compile time.
 Array list in not linked list 
 Array list is wrapper that uses array under the hood.
 Keep track of length,index of head/tail.
 push/pop/acces has 0(1).
 Constructor specifies initial size.
 # Struct 

 # ENUMS 
 Enums are great alternative for the pre-processor constant .
 First we define the value then it automatically take the value from there. 
 Enumerate means om general to count or list items systematically ,in programming it refers to the method or function.
 
 Pre-Processor constant ->

  


# Macro 
```assert_eq!```
This is macro which is used to match the value of varible .
```Rust
fn main(){
    let x=5;
    assert_eq!(x,5);
    println!("The value is matched ");
}
```

  
# Fearless concurrency 
This need to be done after completing the rust by example.


 


# The Rust Standard Library 
 The Rust Standard Library, often referred to simply as "std," is a collection of essential APIs (Application Programming Interfaces) and utilities provided by the Rust programming language. It's included with every Rust distribution and forms a core part of the language ecosystem.
   # Array 
   A fixed-size array,denoted[ELEMENT-type;non negative compile-time conatant size].
   Before sstarting this lets get into ```Derive code```
   In this we have used clone and copy to use the borrowed varable .
   ```Copy```
   It behaviour is  not overloadable.It always do a simple bit wise copy.It do implict copying means that it automatically copy the value instead of moving the data.

   This trait is not object safe.
 ```Rust
 fn main(){
#[derive(Copy,Clone,Debug)]
 struct Apple;
 let c=Apple;
 let d=c;
 print!(" {c:?}",);
 print!(" {d:?}");
 
     }
 ```




 # std::vec::Vec
  A contiguous growable  array type,written as Vec<T>,in short it is known as vector .
 `New` Vec::new() It is keyword which construct an empty vector and it will not allocate  until a new elemets are pushed inti it.
 `Push` Appends an element to the back of a collection.

 `POP` Removes the last element from a vector and returns it, or None if it is empty.
 `Len`Returns the number of elements in the vector, also referred to as its 'length.

  ```RUST
  // A simple demonstration vector expalaing how we can use it 
  fn main(){
    let  numbers :Vec<i32> = vec![1,2,3,4,5,6,7,8,9];
    println!("{:?}",numbers);
}
 // A vector which show the concept of the ownership 
 
fn main(){
    let x:Vec<i32>=vec![4,5,6];
    let y=x; // The value have been borowwed here .
    println!("THE VALUE OF Y IS {:?}",y);

}

// Simple operation on the vector  hav3 been demonstrated.
fn main(){
   
    let mut v:Vec<i8>  = vec![4,5,6];
    println!("origninal vector is {:?}",v);
    v.push(5); // This is for the insertion at the end of the vector.
    println!("origninal vector is {:?}",v);
    v.insert (1,7); //This for the insertion at the specific location .
    println!("{:?}",v);
    let remove_element=v.remove(2);
    println!("THE VALUE AFTER REMOVAL IS {:?}",remove_element);
    v.sort();
    print!("THe sort value is {:?}",v);

    
    
}
fn main(){
    let  mut c:Vec<i128>=vec![ 1,2,3,7];
    println!("The value of c is {:?}",c);
    let    d: &mut Vec<i128>=   &mut c; // Here we have passed the rference of c to the d instead of passsing the the ownership we have pssed the reference .
    println!("The value of d is {:?}",d);
    d.push(5);
    d.insert(1,700);
    d.remove(2);
    println!("The value of d after insertion  is {:?}",d);
    println!("The value of c is {:?}",c);
}
  ```
 The xtended version pv vector with hign end demonstration 
 ```Rust 
 fn main(){
    let mut vec: Vec<i32> =Vec::new();
    vec.push(8);
    vec.push(785);
    assert_eq!(vec.len(),2);
    assert_eq!(vec[0..2],[8,785]); // For the checking of the multiple value in given vector.
    print!("The value is {:?}",vec);

}
fn main(){
  let mut vec :Vec<i128>=Vec::new(); //This vector will not allocate until the data is pushed into it 
  vec.push(5);
  vec.push(6);
  assert_eq!(vec.len(),2);
  assert_eq!(vec[0..2],[5,6]);
  assert_eq!(vec.pop(),Some(5)); //This line will give eeror as acc to pop we can remove the value from end of the array.
  assert_eq!(vec.pop(),Some(6)); // This will work perfectely.
  println!("The value is {:?}",vec);
}
 let f=vec![4,5,6,7];
 println!("THe {:?}",f[3]); // Concept of indexing has been explained .
```
 `Slicing` it means to access the certain part of the vector without modifying the range of the vector.
 ```Rust
 fn main(){
    let d:vec<i8>=Vec[1,2,3,4,5,6];
    let d1=&d[0..3];
    assert_eq!(d.len(),5);
     assert_eq!(d[0..2],[1,2,3,4,5,6]);
    println!("The value is {:?}",d1);
    println!("The value is {:?}",d);
     }
     // Full fledged slice concept 
       
  fn main(){
    let d:Vec<i8>=vec![1,2,3,4,5,6];
    let d1=&d[0..3];
    assert_eq!(d.len(),6);
     assert_eq!(d[0..6],[1,2,3,4,5,6]);
    println!("The value is {:?}",d1);
    println!("The value is {:?}",d);
     }
  ```
  # Capacity 
    Capacity  simple means that the amount of space allocated for any future elemets that will be added onto the vector.
    On the other hand length is the amount of the element into the vector we alredy  have .

# Gurantees
`Vec` makes a lot of gurantees about its  design.This ensure its a low-overhead as possible in the general case,and can be correctly manipulated in primitive ways to unsafe code.
`Vec` never make gurantee about the memoery layout (Memory layout refers to the organization and arrangement of data in computer memory.)including the order of the fileds.
`ABI` is not stable here which means that Application Binary Interface. It refers to the low-level interface between two binary program modules, typically between a library and the applications or other libraries that use it. The ABI defines how functions, data structures, and system calls are represente 


`Uninit` 
It represent memory that is not initilizwd yet.

If we use iterator then there will no reallocation of memmoery .

```Rust
//Printing the vector array in loop as it avoid the reallocation of memory 
fn main(){
    let mut v: Vec<i32> =Vec::new();
 for i in 0..12{
     v.push(i*2-7)
 }
print!("{:?}",v)


}
```

In vector memory allocation concept is quite hectic and for easy and impactfull creation of memeory  allocation we use APIs famously known as `alloc`
 As we have our default memory allocator provided by the operaating system.
 
 
