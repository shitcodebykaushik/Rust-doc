# Control flow
It is the flow of program in which it check the condition and give the result on the basis of that .
In rust we can use ```if```it allow us to branch the code depending upon the condition .
```Rust
 fn main(){
    let x=4;
    ifx ==4{
        println!("The value is correct ");
    }
 }
```
We can use ```else``` with ```if ```
```Rust
fn main(){
    let x=48;
    if x<48{
        println!("x is less then 48");
}else {
    println!("The vslue is more then the require one");
}
}
```
# Loop
In Rust we use Loop keyword to repeat the itteration again and again 
We have to explictily stop the loop by using the  ```Ctrl+c```
```Rust
fn main(){
    loop{
        println!("The loop is looop")
    }
}
To stop this loop we use ctrl+c keyword
```


# RUST Ownership and Borrowing 
Ownership is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.
## Rules of ownership
 [1] There is only owner at a time 
 [2] Each value in rust has owner
 [3]  When the owner goes out of the scope, the value will be dropped.
 # Here is the simple demostrtion
 ```Rust
 fn main(){
 {let k: i32=5; //In this we have defined scope under {} and this is type of varible scope
 println!("s= {}",k);
 }
 println!("s= {}",k); //When we will call this it will give error in program As it is out of scope 
 
}

```
# Returning value from loops


Here is reason why string can be mutaed but string litrals can't.
As we know that string litral content is known at the compile time and its text is hardcoded directly into the final executable .
In case of string we need to allocate an amount of memory on the heap, unknown at the compile time .
# Memoery allocation in rust 
Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope.Then rust called ```drop``` it is function which is automactically called when there is closing curly brakets. 

# Variables and data Interacting 
# Move
Move it is concept in which rust validate the first varible instead of being called a shallow copy it is known as move.
```Rust 
fn main(){
let s1 =String::from("Kaushik rah ");
let s2=s1;
print!("This  is {}",s1);
}
//This code wont work as the value of s1 as been moved to s2 
fn main(){
let s1 =String::from("Kaushik raj ");
let s2=s1;

print!("This  is {}",s2);
}
//On the other this code will run as we call the varible s2 beacuse the ownership of s1 has been passed to s2.
```
# Clone 
 This is concept in rust where it clone the data of data of one variable to another .
 ```Rust
 fn main(){
    let c=String::from("Hey kaushik raj ");
    let d=c.clone();
    println!("This is the value of x = {},This is value of y={}"c ,d);
 }
 
 ```



 This line of code will give error as it we have complex data of string and we cant assign both of them.
 ```Rust
 fn main(){
let x=String::from ("HI");
let y=x;
print!("y is {}",x);
}
```
But on the other side this line of code wont give you error.
 ```RUST
 fn main(){
let x= "HI";
let y=x;
print!("y is {}",x);
}
 ```

 Ownership and Borrowing are why Rust is Rust .
 Owner ship simpliy means owning some amount if memory .
 Initially frustrates both the new and senior developers
 Memory Management 
 No garbage collection 
 Developer manages memoery in code 
 Stacks VS Heap
 Benefits 
 Runtime speed
 Parallel and Concurrent processing 
 Safety 
 In rust memory time is known at the compile time.
 In rust every piece of data in the memory has an memory and there can be only a single owner of memory at a time.
 String is just a collection of u8.
 # Stack
 It store the in the order it gets them and remove the values in the opposite order .It work in the concept of LIFO
 Stack in rust is having known,fixed size.
 Addig data is known is push.
 And removing of data is pop.
 # Heap
 It is less organized,In this when we some amount of data it request for the certain space in  memory .Memory allocator find the space and return a pointer which is adrres of the location.


 

 ```Rust
 #[allow(unused_variables)] //This is so i dont get warning throughout the video
 ```
# Reference and borrowing 
A reference is like a pointer it that its address we can follow to acces the data stored at that address, and that data is owned by some other varible.It guranteed that it will point to that particular data. It should be under scope of the varible. The reference is most common pointer .
It boorow the value of which it has benn pointed .
```Rust
fn main(){
  { let s=5;
   println!("The vsl is ={}",s);};
   let j= &s;
   println!("The vsl is ={}",j);

    }
    //This will generate the error as it going varible is out of the scope 
    fn main(){
     let s=5;
   println!("The vsl is ={}",s);;
   let j= &s;
   println!("The vsl is ={}",j);

    }
    //This will not generate the error it  will properly work on the cocept of refence and borrowing 
``` 
In refernce it can just borrow the data .


# Pointer
In rust we have smart pointer which is like data structure and work similiarly like pointer .
There are many smart pointer in rust std lib and all work is to allow you to have multiple owners by keepinf the tracks of the number of owner and when no owner remain,cleaing up the data .
Apart from borrowing ,the rust smart pointer have capabilities to own the data .
Smart pointer are usually implemented with with the struct .
It usually do  implementation on the ```DREF ``` AND ```Drop```




















# Generic
 Generics refer to a feature that allows you to write code that can operate on different data types while maintaining type safety. Generics enable you to create reusable components (such as functions, structs, or enums) that can work with any data type.
There is no runtime cost in rust. Which means that we 
We can use as many as generic we want 
We just need to define it on Placeholder < Anything in case try upper case >.
In simple terms we can say that we are defing the multiple data types in one go from int to bool and so on.
In therory Generics are called ‘parametric polymorphism’ in type theory, which means that they are types or functions that have multiple forms (‘poly’ is multiple, ‘morph’ is form) over a given parameter (‘parametric’).
Note it is always advisble not to use more genric always.

```rust
struct Point<A,B>{
    x:A,
    y:B,
}

fn main() {
    let a=Point{x:78,y:85.47};
    let v=Point{x:-7,y:956};
     println!("x ={} y={}",a.x,a.y);
     println!("x ={} y={}",v.x,v.y);
     
    
}

```





# Traits
Definig shared behaviour(means method) using traits.
Traits allow us define set of method that are shared across different types 

This is for the concurency control.
The main building block for createing the concurent in rust is a "thread".
There are two main two types of thread in programing in thread .
First type is OS thread.It is offered by OS iteslef.
Second types is Green thread.Its an abstraction thats sit ontop of the operating system thread.
Rust uses the opeerating system thread directly and the reason why is for the the sake of hai=ving a lowet runtike by the lower runtime means the lower amount of code included in each binay after its compiled .
While creating a thread we need to bring the thread namespace first .
Rust doesen't make the gurantee  of the thread order .
# MOVE 
Move(KEYWORD) allow the clouser to move data from one thread to another THREAD and we take the ownership of the main thread.
Move key word force the clousre to refernce data by the value rather than by the reference 
# SECOND ABSTRACTION
Rust uses second abstraction which is called channels.
Channels are use to pass the messsage around and channel is made up of a transmitter which is TX ans a reciver which is RX .
Transmitter is the part that sits upstream where we actually push the message in and then the reciver is where msg come out.
We destruct the tuple that is returned by the channel method and the TX HAS SEND method that takes the value we want to send and return  a result and thats why we use unwrap .
 # ARRAY 
 In array we have some built in functionality with the rust 
 In rust array list is preety much vector.
 Its is knowns at the complie time and its slice is not  known at the compile time.
 Array list in not linked list 
 Array list is wrapper that uses array under the hood.
 Keep track of length,index of head/tail.
 push/pop/acces has 0(1).
 Constructor specifies initial size.
 # Struct 

 # ENUMS 
 Enums are great alternative for the pre-processor constant .
 First we define the value then it automatically take the value from there. 
 Enumerate means om general to count or list items systematically ,in programming it refers to the method or function.
 
 Pre-Processor constant ->

  




  



