
# RUST Ownership and Borrowing 
Ownership is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.
 Ownership and Borrowing are why Rust is Rust 
 Initially frustrates both the new and senior developers
 Memory Management 
 No garbage collection 
 Developer manages memoery in code 
 Stacks VS Heap
 Benefits 
 Runtime speed
 Parallel and Concurrent processing 
 Safety 
 In rust memory time is known at the compile time.
 In rust every piece of data in the memory has an memory and there can be only a single owner of memory at a time.
 String is just a collection of u8.
 # Stack
 It store the in the order it gets them and remove the values in the opposite order .It work in the concept of LIFO
 Stack in rust is having known,fixed size.
 Addig data is known is push.
 And removing of data is pop.


 

 ```Rust
 #[allow(unused_variables)] //This is so i dont get warning throughout the video
 ```















# Generic
 Generics refer to a feature that allows you to write code that can operate on different data types while maintaining type safety. Generics enable you to create reusable components (such as functions, structs, or enums) that can work with any data type.
There is no runtime cost in rust. Which means that we 
We can use as many as generic we want 
We just need to define it on Placeholder < Anything in case try upper case >.
In simple terms we can say that we are defing the multiple data types in one go from int to bool and so on.
In therory Generics are called ‘parametric polymorphism’ in type theory, which means that they are types or functions that have multiple forms (‘poly’ is multiple, ‘morph’ is form) over a given parameter (‘parametric’).
Note it is always advisble not to use more genric always.

```rust
struct Point<A,B>{
    x:A,
    y:B,
}

fn main() {
    let a=Point{x:78,y:85.47};
    let v=Point{x:-7,y:956};
     println!("x ={} y={}",a.x,a.y);
     println!("x ={} y={}",v.x,v.y);
     
    
}

```





# Traits
Definig shared behaviour(means method) using traits.
Traits allow us define set of method that are shared across different types 

This is for the concurency control.
The main building block for createing the concurent in rust is a "thread".
There are two main two types of thread in programing in thread .
First type is OS thread.It is offered by OS iteslef.
Second types is Green thread.Its an abstraction thats sit ontop of the operating system thread.
Rust uses the opeerating system thread directly and the reason why is for the the sake of hai=ving a lowet runtike by the lower runtime means the lower amount of code included in each binay after its compiled .
While creating a thread we need to bring the thread namespace first .
Rust doesen't make the gurantee  of the thread order .
# MOVE 
Move(KEYWORD) allow the clouser to move data from one thread to another THREAD and we take the ownership of the main thread.
Move key word force the clousre to refernce data by the value rather than by the reference 
# SECOND ABSTRACTION
Rust uses second abstraction which is called channels.
Channels are use to pass the messsage around and channel is made up of a transmitter which is TX ans a reciver which is RX .
Transmitter is the part that sits upstream where we actually push the message in and then the reciver is where msg come out.
We destruct the tuple that is returned by the channel method and the TX HAS SEND method that takes the value we want to send and return  a result and thats why we use unwrap .
 # ARRAY 
 In array we have some built in functionality with the rust 
 In rust array list is preety much vector.
 Its is knowns at the complie time and its slice is not  known at the compile time.
 Array list in not linked list 
 Array list is wrapper that uses array under the hood.
 Keep track of length,index of head/tail.
 push/pop/acces has 0(1).
 Constructor specifies initial size.

  



